#             Copyright Kohei Takahashi 2012.
#    Distributed under the Boost Software License, Version 1.0.
#       (See accompanying file LICENSE_1_0.txt or copy at
#             http://www.boost.org/LICENSE_1_0.txt)

import "class" : new ;
import common ;
import feature : feature ;
import generators ;
import modules ;
import toolset : flags ;
import type ;
import unix ;

if [ MATCH (--debug-configuration) : [ modules.peek : ARGV ] ]
{
    .debug-configuration = true ;
}

feature.extend toolset : $(__name__) ;
toolset.inherit-generators $(__name__) : unix : unix.link unix.link.dll ;
toolset.inherit $(__name__) : unix ;

generators.override $(__name__).prebuilt : builtin.lib-generator ;
generators.override $(__name__).prebuilt : builtin.prebuilt ;
generators.override $(__name__).searched-lib-generator : searched-lib-generator ;

rule init ( version ? : command * : options * )
{
    local condition = [ common.check-init-parameters $(__name__) : version $(version) ] ;

    local command = [ common.get-invocation-command $(__name__) : nvcc : $(command) ] ;

    handle-options $(__name__) : $(condition) : $(command) : $(options) ;
}

local rule handle-options ( toolset : condition * : command * : options * )
{
    common.handle-options $(toolset) : $(condition) : $(command) : $(options) ;

    flags $(__name__).compile.cu OPTIONS $(condition)
      : [ feature.get-values <cuflags> : $(options) ]
      : unchecked ;
}

class CUDA-compiling-generator : C-compiling-generator
{
}

rule register-cuda-compiler ( id :
    source-types + : target-types + :
    requirements * : optional-properties * )
{
    generators.register [ new CUDA-compiling-generator $(id) : $(source-types)
                            : $(target-types) : <toolset>$(__name__) $(requirements)
                            : $(optional-properties) ] ;
}

IMPORT $(__name__) : register-cuda-compiler : : generators.register-cuda-compiler ;

# FIXME: target feature should be non-free feature.
feature target : ptx cubin : free optional ;
flags $(__name__).compile OPTIONS <target>ptx : --ptx ;
flags $(__name__).compile OPTIONS <target>cubin : --cubin ;

generators.register-cuda-compiler $(__name__).compile.cu : CUDA : OBJ ;
generators.register-cuda-compiler $(__name__).compile.cu : CUDA : PTX : <target>ptx ;
generators.register-cuda-compiler $(__name__).compile.cu : CUDA : CUBIN : <target>cubin ;

# FIXME: These are not very good way to change output suffix.
type.set-generated-target-suffix OBJ : <toolset>$(__name__) : o ;
type.set-generated-target-suffix OBJ : <toolset>$(__name__) <target>ptx : ptx ;
type.set-generated-target-suffix OBJ : <toolset>$(__name__) <target>cubin : cubin ;

flags $(__name__).compile OPTIONS <address-model>32 : -m32 ;
flags $(__name__).compile OPTIONS <address-model>64 : -m64 ;

flags $(__name__).compile OPTIONS <debug-symbols>on : -g ;

feature device-debug-symbols : off on : propagated ;
flags $(__name__).compile OPTIONS <device-debug-symbols>on : -G ;

feature gpu-architecture : : free optional ;
flags $(__name__).compile OPTIONS <gpu-architecture> ;
rule setup-gpu-architecture ( targets * : sources * : properties * )
{
    local arch = [ feature.get-values gpu-architecture : $(properties) ] ;
    if $(arch)
    {
        ECHO "** warning ** nvcc.jam: sorry, not impremented GPU architecture selector yet." ;
    }
}

feature gpu-code : : free optional ;
flags $(__name__).compile OPTIONS <gpu-code> ;
rule setup-gpu-code ( targets * : sources * : properties * )
{
    local code = [ feature.get-values gpu-code : $(properties) ] ;
    if $(code)
    {
        ECHO "** warning ** nvcc.jam: sorry, not impremented GPU code selector yet." ;
    }
}

flags $(__name__).compile DEFINES <define> ;
flags $(__name__).compile INCLUDES <include> ;

feature cuflags : : free optional ;
flags $(__name__).compile.cu OPTIONS <cuflags> ;

rule compile.cu ( targets * : sources * : properties * )
{
    local target = [ feature.get-values target : $(properties) ] ;
    switch $(target)
    {
        case "" :
          OPTIONS on $(targets) += -c ;
        case "ptx" :
        case "cubin" :
        case * :
          EXIT "** error ** nvcc.jam: invalid target (" $(target) ")." ;
    }

    setup-gpu-architecture $(targets) : $(sources) : $(properties) ;
    setup-gpu-code $(targets) : $(sources) : $(properties) ;
}

actions compile.cu
{
    $(CONFIG_COMMAND) $(OPTIONS) -D$(DEFINES) -I"$(INCLUDES)" -o "$(<)" "$(>)"
}

flags $(__name__).link LINKPATH <library-path> ;
flags $(__name__).link LIBRARIES <library-file> ;
flags $(__name__).link OPTIONS <linkflags> ;
#flags $(__name__).link OPTIONS <link>shared : --shared ;
#flags $(__name__).link OPTIONS <runtime-link>shared : --shared ;

#rule link ( targets * : sources * : properties * )
#{
#}

actions link bind LIBRARIES
{
    $(CONFIG_COMMAND) $(OPTIONS) -L"$(LINKPATH)" -o "$(<)" "$(>)" $(LIBRARIES)
}
