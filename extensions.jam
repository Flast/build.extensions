#             Copyright Kohei Takahashi 2012.
#    Distributed under the Boost Software License, Version 1.0.
#       (See accompanying file LICENSE_1_0.txt or copy at
#             http://www.boost.org/LICENSE_1_0.txt)

import modules ;
import path ;
import set ;

.$(__name__)-already-initialized = ;

.$(__name__)-subdirs =
  tools
  util
  ;

local rule root ( )
{
    if ! $(.$(__name__)-already-initialized)
    {
        local file-path = [ modules.binding $(__name__) ] ;
        .$(__name__)-already-initialized = $(file-path:DT) ;
    }
    return $(.$(__name__)-already-initialized) ;
}

rule prefix ( module-name )
{

    return $(__name__):$(module-name) ;
}

local rule export-rules ( target-modules + )
{
    # To be able to use rules in each extensions, import rules as under
    # 'extensions' module.
    local rules = import prefix root using ;
    for local m in $(target-modules)
    {
        IMPORT $(__name__) : $(rules) : [ prefix $(m) ] : extensions.$(rules) ;
    }
}

# In pre-import/import-really, use extensions/original prefix to avoid polluting
# caller-module's namespace.
local rule pre-import ( module-names + : search * : caller-module )
{
    export-rules $(module-names) ;

    IMPORT modules : load : $(caller-module)
      : extensions/original/modules.load ;
    IMPORT $(__name__) : prefix : $(caller-module)
      : extensions/extensions.prefix ;

    module $(caller-module)
    {
        local .modules = extensions/original/modules ;
        for local m in $(1)
        {
            $(.modules).load [ extensions/extensions.prefix $(m) ]
              : $(m).jam : $(2) ;
        }
    }
}

local rule import-really ( module-names + : rule-opt * : rename-opt *
  : caller-module )
{
    IMPORT modules : import : $(caller-module)
      : extensions/original/modules.import ;
    IMPORT $(__name__) : prefix : $(caller-module)
      : extensions/extensions.prefix ;

    module $(caller-module)
    {
        local .modules = extensions/original/modules ;
        for local m in $(1)
        {
            $(.modules).import [ extensions/extensions.prefix $(m) ]
              : $(2) : $(3) ;
        }
    }
}

local rule path-join ( p1 : p2 * )
{
    local result ;
    for local p in $(p2)
    {
        result += [ path.join $(p1) $(p) ] ;
    }
    return $(result) ;
}

.$(__name__)-loaded = ;
rule import ( module-names + : rule-opt * : rename-opt * )
{
    local caller = [ CALLER_MODULE ] ;

    # Check and skip already loaded modules to avoid recursive importing.
    local load = [ set.difference $(module-names) : $(.$(__name__)-loaded) ] ;
    if $(load)
    {
        .$(__name__)-loaded += $(load) ;

        local search = [ path-join [ root ] : $(.$(__name__)-subdirs) ] ;
        pre-import $(load) : $(search) : $(caller) ;
    }
    import-really $(module-names) : $(rule-opt) : $(rename-opt)
      : $(caller) ;
}

rule using ( toolset-module : * )
{
    import $(toolset-module) ;
    toolset-module = [ prefix $(toolset-module) ] ;
    $(toolset-module).init $(2) : $(3) : $(4) : $(5) : $(6) : $(7) : $(8) : $(9) ;
}

import types/register ;


### build-request module hijacking ###
# XXX: Following modules/rules depends on build-system.jam behaviour.
# Thus, some later releases might not work.

modules.poke [ prefix build-request ] : __name__ : [ prefix build-request ] ;
export-rules build-request ;

module [ prefix build-request ]
{
    import build-request ;

    .build-request = extensions/original/bulid-request ;
    .build-system = extensions/original/bulid-system ;

    local rule handle-toolset-configurations ( argv * )
    {
        import feature ;

        local toolsets ;
        for local a in $(argv)
        {
            local t = [ MATCH ^--ext-toolset=(.*)$ : $(a) ]
              [ MATCH ^ext-toolset=(.*)$ : $(a) ] ;
            if $(t)
            {
                toolsets += $(t) ;
            }
        }

        local extra-properties ;
        for local t in $(toolsets)
        {
            local (t,...) = [ MATCH ^([^-]+)-?(.+)?$ : $(t) ] ;

            if ! $(t) in [ feature.values <toolset> ]
            {
                extensions.using $((t,...)[1]) : $((t,...)[2]) ;
            }

            local prefixed-toolset = [ extensions.prefix $(t) ] ;
            if ! toolset=$(t) in $(argv)
              || ! toolset=$(prefixed-toolset) in $(argv)
            {
                extra-properties += toolset=$(prefixed-toolset) ;
            }
        }
        return $(extra-properties) ;
    }

    rule process-explicit-toolset-requests ( )
    {
        import modules ;

        local argv = [ modules.peek : ARGV ] ;

        local ext-toolsets = [ handle-toolset-configurations $(argv) ] ;
        local extra-toolsets = [ $(.build-system).process-explicit-toolset-requests ] ;

        return $(extra-toolsets) $(ext-toolsets) ;
    }

    IMPORT build-system : process-explicit-toolset-requests
      : $(__name__) : $(.build-system).process-explicit-toolset-requests ;
    IMPORT $(__name__) : process-explicit-toolset-requests
      : build-system : process-explicit-toolset-requests ;

    local rule is-not-ext-toolset ( property )
    {
        if ! [ MATCH ^ext-toolset=(.*)$ : $(property) ]
        {
            return true ;
        }
    }

    rule from-command-line ( command-line * )
    {
        import sequence ;

        # Remove ext-toolset= to avoid generate <ext-toolset> feature by build-system.
        local properties = [ sequence.filter is-not-ext-toolset : $(command-line) ] ;

        return [ $(.build-request).from-command-line $(properties) ] ;
    }

    IMPORT build-request : from-command-line
      : $(__name__) : $(.build-request).from-command-line ;
    IMPORT $(__name__) : from-command-line
      : build-system : build-request.from-command-line ;
}
